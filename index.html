<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>雪結晶 成長シミュレーター（調整済み / 六角格子CA）</title>
<style>
  :root{
    --bg:#0b1020; --panel:#111a33cc; --ink:#e9eeff; --muted:#aab4dd;
    --btn:#1e2b59; --btn2:#27387a; --accent:#7dd3fc;
  }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(1000px 600px at 30% 10%, #182b66 0%, var(--bg) 60%);
       color:var(--ink); font-family:system-ui,-apple-system,"M PLUS Rounded 1c",sans-serif;}
  header{position:sticky;top:0;z-index:5;background:linear-gradient(#0b1020ee,#0b102000);
         padding:12px 14px 10px; backdrop-filter: blur(6px);}
  h1{margin:0;font-size:16px;font-weight:700;letter-spacing:.02em}
  .wrap{display:grid;grid-template-columns: 1fr; gap:10px; padding:10px 12px 16px; max-width:1100px; margin:0 auto;}
  @media (min-width: 980px){ .wrap{grid-template-columns: 1fr 360px;} }
  .card{background:var(--panel); border:1px solid #2a3a7a55; border-radius:14px; overflow:hidden;}
  .stage{padding:10px;}
  canvas{width:100%;height:auto;display:block;border-radius:12px;background:#070b16; border:1px solid #2a3a7a55;}
  .side{padding:12px 12px 10px; display:flex; flex-direction:column; gap:10px;}
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
  .btn{
    border:0; padding:10px 12px; border-radius:12px; color:var(--ink);
    background:linear-gradient(180deg,var(--btn2),var(--btn)); cursor:pointer;
    font-weight:700; letter-spacing:.02em;
  }
  .btn:active{transform:translateY(1px)}
  .btn.ghost{background:#0000;border:1px solid #2a3a7a88}
  label{font-size:12px;color:var(--muted)}
  input[type="range"]{width:100%}
  .kv{display:grid; grid-template-columns: 1fr auto; gap:6px 10px; font-size:12px; color:var(--muted)}
  .kv b{color:var(--ink); font-weight:700}
  .note{font-size:12px;color:var(--muted); line-height:1.45}
  .pill{display:inline-block;padding:4px 10px;border-radius:999px;background:#0f1a3e;border:1px solid #2a3a7a66;font-size:12px;color:var(--muted)}
  .warn{color:#ffd88a}
</style>
</head>
<body>
<header>
  <h1>❄️ 雪結晶 成長シミュレーター（調整済み：−5板状 / −15樹枝状 / −30荒く小さい）</h1>
</header>

<div class="wrap">
  <div class="card stage">
    <canvas id="cv" width="900" height="900" aria-label="snowflake canvas"></canvas>
  </div>

  <div class="card side">
    <div class="row">
      <button id="btnStart" class="btn">▶ 開始</button>
      <button id="btnStep" class="btn ghost">＋1ステップ</button>
      <button id="btnReset" class="btn ghost">↺ リセット</button>
    </div>

    <div class="row">
      <span class="pill">温度プリセット</span>
      <button class="btn ghost" data-preset="-5">−5℃（板状）</button>
      <button class="btn ghost" data-preset="-15">−15℃（樹枝状）</button>
      <button class="btn ghost" data-preset="-30">−30℃（荒い）</button>
    </div>

    <div>
      <label>温度: <b id="tempLabel">−15℃</b></label>
      <input id="temp" type="range" min="-35" max="-2" step="1" value="-15">
    </div>

    <div>
      <label>水蒸気量（過飽和度）: <b id="supLabel">高</b></label>
      <input id="sup" type="range" min="0" max="100" step="1" value="85">
    </div>

    <div class="row">
      <label style="display:flex;gap:8px;align-items:center">
        <input id="symLock" type="checkbox">
        6回対称ロック（ONにすると六角形に寄りがち）
      </label>
    </div>

    <div class="row">
      <label style="display:flex;gap:8px;align-items:center">
        <input id="showVapor" type="checkbox">
        水蒸気（背景）を表示
      </label>
    </div>

    <div class="kv">
      <div>ステップ</div><b id="steps">0</b>
      <div>氷セル数</div><b id="iceCount">0</b>
      <div>内部パラメータ</div><b id="params">—</b>
    </div>

    <div class="note">
      <b>調整点（重要）：</b><br>
      −15℃では <span class="warn">「角優先を強く」</span> しつつ、<br>
      <span class="warn">表面拡散を弱め＆ノイズを増やして</span> 枝分かれを作ります。<br>
      まずは <b>−15℃＋水蒸気「高」</b> で試してください。<br>
      （6回対称ロックはOFF推奨）
    </div>
  </div>
</div>

<script>
/* ============
  調整済み 六角格子CA
  目標：温度で形がちゃんと変わる
  -5℃：表面拡散強め/ノイズ少 → 板状で整う
  -15℃：角優先強/表面拡散弱/ノイズ中 → 樹枝状
  -30℃：動けない（拡散弱）/付着高/ノイズ高 → 小さく荒い
=========== */

const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');

const ui = {
  btnStart: document.getElementById('btnStart'),
  btnStep: document.getElementById('btnStep'),
  btnReset: document.getElementById('btnReset'),
  temp: document.getElementById('temp'),
  sup: document.getElementById('sup'),
  tempLabel: document.getElementById('tempLabel'),
  supLabel: document.getElementById('supLabel'),
  symLock: document.getElementById('symLock'),
  showVapor: document.getElementById('showVapor'),
  steps: document.getElementById('steps'),
  iceCount: document.getElementById('iceCount'),
  params: document.getElementById('params'),
};

const W = cv.width, H = cv.height;

// シミュレーション領域（半径Rの六角領域）
let R = 120;
let running = false;
let rafId = null;

// 6方向（軸座標）
const DIRS = [
  [ 1, 0], [ 1,-1], [ 0,-1],
  [-1, 0], [-1, 1], [ 0, 1]
];

// 60度回転（軸座標 q,r）
function rot60(q,r){
  const x=q, z=r, y=-x-z;
  const x2 = -z, y2 = -x, z2 = -y;
  return [x2, z2];
}
function rotN(q,r,n){
  let a=q,b=r;
  for(let i=0;i<n;i++){ [a,b]=rot60(a,b); }
  return [a,b];
}

function inHex(q,r){
  const x=q, z=r, y=-x-z;
  return Math.max(Math.abs(x),Math.abs(y),Math.abs(z)) <= R;
}
const key = (q,r)=> `${q},${r}`;

// 状態
let ice = new Map();   // key -> 1
let vapor = new Map(); // key -> float
let stepCount = 0;
let iceCount = 0;

function clamp(x,a,b){ return Math.max(a,Math.min(b,x)); }
function lerp(a,b,t){ return a+(b-a)*t; }

// 過飽和度スライダー -> 供給量（強め寄りに調整）
function supplyFromSup(s){
  // 0..100 -> 0.10..2.80
  return 0.10 + 2.70*(s/100);
}

/*
  温度→パラメータ（調整済み）
  P = {
    anis    : 角優先（大きいほど枝が走る）
    surf    : 表面拡散（大きいほど整って板状になりやすい）
    stick   : 付着しやすさ
    airDiff : 気相拡散（大きいほど材料が均され、太りやすい）
    noise   : 揺らぎ（大きいほど枝分かれ/荒れ）
  }
*/
function paramsFromTemp(tC){
  // -15付近ピーク
  const peak15 = Math.exp(-Math.pow((tC + 15)/6.2, 2));
  // -5付近ピーク（板状寄り）
  const peak5  = Math.exp(-Math.pow((tC + 5)/4.8, 2));
  // 低温側強度（-35で1, -2で0）
  const cold = clamp(((-2) - tC) / 33, 0, 1);

  // 異方性：-15で最大（枝の先端が走る）
  const anis = clamp(0.35 + 0.55*peak15, 0.25, 0.95);

  // 表面拡散：-5で強め（板状）、-15は弱め（枝分かれ）、極低温はさらに弱い
  const surf = clamp(0.05 + 0.22*peak5 + 0.06*(1-peak15)*0.35, 0.04, 0.32);

  // 付着：低温ほど上がる。ただし-15は「付きすぎ」だと太るので少し抑える
  const stick = clamp(0.28 + 0.42*cold - 0.10*peak15, 0.18, 0.78);

  // 気相拡散：温かいほど大、低温ほど小（材料が局在→枝が出やすい）
  const airDiff = clamp(0.06 + 0.18*(1-cold), 0.05, 0.24);

  // ノイズ：-15でも少し確保（枝分かれを作る）、極低温は荒れやすく上げる
  const noise = clamp(0.03 + 0.05*peak15 + 0.05*cold, 0.02, 0.14);

  return {anis, surf, stick, airDiff, noise};
}

function reset(){
  ice.clear();
  vapor.clear();
  stepCount = 0;
  iceCount = 0;

  // 初期：全セルに水蒸気
  for(let q=-R;q<=R;q++){
    for(let r=-R;r<=R;r++){
      if(!inHex(q,r)) continue;
      vapor.set(key(q,r), 1.0);
    }
  }

  // 中央核
  setIce(0,0,true);
  draw();
  updateUI();
}

function getV(q,r){ return vapor.get(key(q,r)) ?? 0; }
function setV(q,r,val){ vapor.set(key(q,r), val); }
function isIce(q,r){ return ice.has(key(q,r)); }

function setIce(q,r,forceNoSym=false){
  const k = key(q,r);
  if(!ice.has(k)){
    ice.set(k,1);
    iceCount++;
  }
  // 6回対称ロック（ONの場合のみ）
  if(ui.symLock.checked && !forceNoSym){
    for(let n=1;n<6;n++){
      const [qq,rr]=rotN(q,r,n);
      if(!inHex(qq,rr)) continue;
      const kk=key(qq,rr);
      if(!ice.has(kk)){
        ice.set(kk,1);
        iceCount++;
      }
    }
  }
}

function neighbors(q,r){
  const out=[];
  for(const [dq,dr] of DIRS) out.push([q+dq, r+dr]);
  return out;
}

// 境界（氷の隣の非氷）
function collectBoundary(){
  const cand = new Map(); // key -> {q,r, nIceNeighbors}
  for(const k of ice.keys()){
    const [q,r]=k.split(',').map(Number);
    for(const [nq,nr] of neighbors(q,r)){
      if(!inHex(nq,nr)) continue;
      if(isIce(nq,nr)) continue;
      const nk=key(nq,nr);
      const cur = cand.get(nk);
      if(cur) cur.nIceNeighbors++;
      else cand.set(nk, {q:nq,r:nr,nIceNeighbors:1});
    }
  }
  return [...cand.values()];
}

// 角っぽさ（先端ほど大）
function cornerScore(nIceNeighbors){
  if(nIceNeighbors<=1) return 1.0;   // 先端
  if(nIceNeighbors===2) return 0.65; // 枝
  if(nIceNeighbors===3) return 0.30; // 角が潰れてくる
  return 0.12;                       // 面
}

// 1ステップ
function step(){
  const tC = Number(ui.temp.value);
  const sup = Number(ui.sup.value);
  const P = paramsFromTemp(tC);
  const supply = supplyFromSup(sup);

  // (A) 気相拡散（vapor平滑化）
  const newV = new Map(vapor);
  for(let q=-R;q<=R;q++){
    for(let r=-R;r<=R;r++){
      if(!inHex(q,r)) continue;
      const k = key(q,r);
      if(isIce(q,r)) { newV.set(k, 0); continue; }
      let sum = getV(q,r), cnt = 1;
      for(const [nq,nr] of neighbors(q,r)){
        if(!inHex(nq,nr)) continue;
        if(isIce(nq,nr)) continue;
        sum += getV(nq,nr);
        cnt++;
      }
      const avg = sum / cnt;
      const v = getV(q,r);
      newV.set(k, v + P.airDiff*(avg - v));
    }
  }
  vapor = newV;

  // (B) 供給：端から入りやすい（枝が伸びる材料）
  for(let q=-R;q<=R;q++){
    for(let r=-R;r<=R;r++){
      if(!inHex(q,r)) continue;
      if(isIce(q,r)) continue;
      const x=q, z=r, y=-x-z;
      const dist = Math.max(Math.abs(x),Math.abs(y),Math.abs(z)) / R; // 0..1
      const add = supply * (0.10 + 0.28*dist);
      setV(q,r, getV(q,r) + add);
    }
  }

  const boundary = collectBoundary();

  // (C) 表面拡散：整列しすぎると板状になるので、-15では弱めに働く（P.surfが小さくなる）
  if(boundary.length>0 && P.surf>0){
    const bset = new Set(boundary.map(o=>key(o.q,o.r)));
    const delta = new Map();
    for(const b of boundary){
      const v = getV(b.q,b.r);
      if(v<=0) continue;

      // 近傍境界の中で「より先端（角）」へ少し流す
      let best = null, bestScore = -1;
      for(const [nq,nr] of neighbors(b.q,b.r)){
        const nk = key(nq,nr);
        if(!bset.has(nk)) continue;
        let ni=0;
        for(const [aq,ar] of neighbors(nq,nr)){
          if(isIce(aq,ar)) ni++;
        }
        const s = cornerScore(ni);
        if(s>bestScore){ bestScore=s; best={q:nq,r:nr}; }
      }
      if(!best) continue;

      const move = v * P.surf * 0.22; // 調整済み（強すぎない）
      if(move<=0) continue;

      const k1 = key(b.q,b.r), k2 = key(best.q,best.r);
      delta.set(k1, (delta.get(k1)||0) - move);
      delta.set(k2, (delta.get(k2)||0) + move);
    }
    for(const [k,d] of delta){
      const [q,r]=k.split(',').map(Number);
      setV(q,r, Math.max(0, getV(q,r) + d));
    }
  }

  // (D) 成長（付着）
  // ここが樹枝状の主役：
  //  - cornerScore が高いほど（先端ほど）成長が加速
  //  - anis を強く効かせる
  //  - sup（過飽和度）が高いほど分岐しやすい（ノイズも効く）
  const growList = [];
  const sup01 = sup/100;

  for(const b of boundary){
    const v = getV(b.q,b.r);
    if(v<=0) continue;

    const cs = cornerScore(b.nIceNeighbors);

    // 先端加速（anis強化）
    // 先端(cs=1)で最大倍率、面(cs低)は抑制
    const tipBoost = 1.0 + (5.2 * P.anis) * Math.pow(cs, 1.35);

    // supersaturationが高いと枝分かれが出やすい（供給＋ゆらぎ）
    const ssBoost = 0.75 + 1.25*sup01;

    // 基本の付着確率：vが多いほど上がる（飽和曲線）
    let base = (1 - Math.exp(-v*0.05)) * P.stick;

    // 面は太りやすいので抑える（板状化防止）
    base *= (0.55 + 0.45*cs);

    // 合成
    let p = base * tipBoost * ssBoost;

    // ノイズ（-15でも確保して分岐が出る）
    p += (Math.random()-0.5) * P.noise * (0.6 + 0.9*sup01);

    p = clamp(p, 0, 0.98);

    if(Math.random() < p){
      growList.push([b.q,b.r, v]);
    }
  }

  // 氷化 & 消費（消費を強めると枝が細くなりやすい）
  for(const [q,r,v] of growList){
    setIce(q,r);
    setV(q,r, Math.max(0, v*0.08)); // 残しを少なめ＝樹枝状寄り
  }

  stepCount++;
}

// 描画
function axialToXY(q,r,size){
  const x = size * (Math.sqrt(3)*q + Math.sqrt(3)/2*r);
  const y = size * (3/2*r);
  return [x,y];
}
function drawHex(x,y,size){
  ctx.beginPath();
  for(let i=0;i<6;i++){
    const a = (Math.PI/180) * (60*i - 30);
    const px = x + size*Math.cos(a);
    const py = y + size*Math.sin(a);
    if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.closePath();
}

function draw(){
  ctx.clearRect(0,0,W,H);

  const size = Math.min(W,H) / (R*2.35);
  const cx = W/2, cy = H/2;

  // vapor表示
  if(ui.showVapor.checked){
    for(let q=-R;q<=R;q++){
      for(let r=-R;r<=R;r++){
        if(!inHex(q,r)) continue;
        if(isIce(q,r)) continue;
        const v = getV(q,r);
        const t = clamp(v/28, 0, 1);
        if(t<=0) continue;
        const [x,y]=axialToXY(q,r,size);
        ctx.fillStyle = `rgba(125, 211, 252, ${0.16*t})`;
        drawHex(cx+x, cy+y, size*0.98);
        ctx.fill();
      }
    }
  }

  // 氷
  ctx.fillStyle = "rgba(240, 248, 255, 0.98)";
  for(const k of ice.keys()){
    const [q,r]=k.split(',').map(Number);
    const [x,y]=axialToXY(q,r,size);
    drawHex(cx+x, cy+y, size*0.98);
    ctx.fill();
  }

  // 輪郭
  ctx.strokeStyle = "rgba(125, 211, 252, 0.22)";
  ctx.lineWidth = 1;
  for(const k of ice.keys()){
    const [q,r]=k.split(',').map(Number);
    const [x,y]=axialToXY(q,r,size);
    drawHex(cx+x, cy+y, size*0.98);
    ctx.stroke();
  }
}

function updateUI(){
  const tC = Number(ui.temp.value);
  const sup = Number(ui.sup.value);
  ui.tempLabel.textContent = `${tC}℃`;
  ui.steps.textContent = String(stepCount);
  ui.iceCount.textContent = String(iceCount);

  ui.supLabel.textContent =
    sup<33 ? "低" :
    sup<67 ? "中" : "高";

  const P = paramsFromTemp(tC);
  ui.params.textContent =
    `anis=${P.anis.toFixed(2)} / surf=${P.surf.toFixed(2)} / stick=${P.stick.toFixed(2)} / airDiff=${P.airDiff.toFixed(2)} / noise=${P.noise.toFixed(2)}`;
}

function loop(){
  if(!running) return;
  // 1フレームで複数ステップ（速すぎると見づらいので控えめ）
  for(let i=0;i<3;i++) step();
  draw();
  updateUI();
  rafId = requestAnimationFrame(loop);
}

ui.btnStart.addEventListener('click', ()=>{
  running = !running;
  ui.btnStart.textContent = running ? "⏸ 停止" : "▶ 開始";
  if(running) loop();
  else if(rafId) cancelAnimationFrame(rafId);
});

ui.btnStep.addEventListener('click', ()=>{
  if(running) return;
  step();
  draw();
  updateUI();
});

ui.btnReset.addEventListener('click', ()=>{
  running = false;
  ui.btnStart.textContent = "▶ 開始";
  if(rafId) cancelAnimationFrame(rafId);
  reset();
});

ui.temp.addEventListener('input', ()=> updateUI());
ui.sup.addEventListener('input', ()=> updateUI());
ui.showVapor.addEventListener('change', ()=> draw());

document.querySelectorAll('[data-preset]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    ui.temp.value = btn.getAttribute('data-preset');
    // プリセットに合わせて過飽和度も少し寄せる（見えやすさ）
    const t = Number(ui.temp.value);
    if(t === -15) ui.sup.value = 90;
    if(t === -5)  ui.sup.value = 55;
    if(t === -30) ui.sup.value = 75;
    updateUI();
  });
});

// 初期化（-15樹枝状が出やすい設定）
reset();
updateUI();
</script>
</body>
</html>
